#include <stdio.h>
#include <windows.h>
#include <winternl.h>

/*

0:006> dt _ldr_data_table_entry
combase!_LDR_DATA_TABLE_ENTRY
   +0x000 InLoadOrderLinks : _LIST_ENTRY
   +0x010 InMemoryOrderLinks : _LIST_ENTRY
   +0x020 InInitializationOrderLinks : _LIST_ENTRY
   +0x030 DllBase          : Ptr64 Void
   +0x038 EntryPoint       : Ptr64 Void
   +0x040 SizeOfImage      : Uint4B
   +0x048 FullDllName      : _UNICODE_STRING
   +0x058 BaseDllName      : _UNICODE_STRING

0:006> dt _list_entry
combase!_LIST_ENTRY
   +0x000 Flink            : Ptr64 _LIST_ENTRY
   +0x008 Blink            : Ptr64 _LIST_ENTRY

*/

// typedef struct _LIST_ENTRY_ {
//     _LIST_ENTRY *Flink;
//     _LIST_ENTRY *Blink;
// } LIST_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY_A_ {
    LIST_ENTRY      InMemoryOrderLinks;
    LIST_ENTRY      InInitializationOrderLinks;
    UINT64*         DllBase;
    UINT64*         EntryPoint;
    UINT32          SizeOfImage;
    UNICODE_STRING  FullDllName;
    UNICODE_STRING  BaseDllName;
} LDR_DATA_TABLE_ENTRY_A, *PLDR_DATA_TABLE_ENTRY_A;

DWORD calculate_dll_hash(wchar_t *dll_name) {

    DWORD dll_len = wcslen(dll_name) * 2;
    DWORD idx = 0;
    DWORD result = 0;
    while (idx != dll_len) {
        char ch = *(char*)((char *)dll_name + idx);
        
        if (ch >= 0x61) {
            ch = ch - 0x20;
        }

        result = (0x401 * (result + ch)) ^ ((0x401 * (result + ch)) >> 6);
        idx++;
    }

    return ((0x8001 * (((9 * result) >> 11) ^ (9 * result))) >> 9) + 0x8001 * (((9 * result) >> 11) ^ (9 * result));

}

unsigned char *resolve_dll(DWORD dll_hash) {
    
    PEB *peb = (PEB*)__readgsqword(0x60);
    PEB_LDR_DATA *ldr = peb->Ldr;
    LIST_ENTRY entry = ldr->InMemoryOrderModuleList;
    LIST_ENTRY *next = (LIST_ENTRY*)entry.Flink;
    DWORD calculated_dll_hash;

    while (1) {

        LDR_DATA_TABLE_ENTRY_A *ldr_table = (LDR_DATA_TABLE_ENTRY_A*)next;

        if (ldr_table->DllBase == 0) {
            break;
        }

        // wprintf(L"%ws\n", ldr_table->BaseDllName.Buffer);

        calculated_dll_hash = calculate_dll_hash(ldr_table->BaseDllName.Buffer);
        if (calculated_dll_hash == dll_hash) {
            wprintf(L"found dll: %ws at: %p\n", ldr_table->BaseDllName.Buffer, ldr_table->DllBase);
            return (unsigned char*)ldr_table->DllBase;
        }

        next = next->Flink;
    }

    return NULL;

}

unsigned char * get_ntdll_base() {

    PEB* peb = (PEB*)__readgsqword(0x60);
    IMAGE_NT_HEADERS64 *nt_headers;
    unsigned char *dos_header = (unsigned char*)peb->Ldr;

    while (1) {

        if (*(WORD*)dos_header == 0x5a4d) {
        
            DWORD *e_lfanew = (DWORD*)(dos_header + 0x3c);
        
            if (*e_lfanew - 0x40 < 0x3bf) {
                nt_headers = (IMAGE_NT_HEADERS64*)(dos_header + *(unsigned char*)e_lfanew);
                if (nt_headers->Signature == 0x4550) {
                    return dos_header;
                }
            }
        }
        dos_header--;
    }
    return dos_header;
}

DWORD calculate_api_hash(char *api_name) {

    unsigned char ch;
    DWORD32 i = 0;

    while (1) {
        ch = *api_name;
        if (ch == 0) {
            break;
        }
        i = (0x401 * (i + ch)) ^ ((0x401 * (i + ch)) >> 6);
        ++api_name;
    }

    return ((0x8001 * (((9 * i) >> 11) ^ (9 * i))) >> 9) + 0x8001 * (((9 * i) >> 11) ^ (9 * i));

}


unsigned char *get_api_addr(unsigned char *dll_base, DWORD api_hash) {

    IMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER*)dll_base;
    IMAGE_NT_HEADERS64 *nt_headers = (IMAGE_NT_HEADERS64*)(dll_base + dos_header->e_lfanew);

    IMAGE_EXPORT_DIRECTORY *export_directory = (IMAGE_EXPORT_DIRECTORY*)(dll_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    DWORD *name_arr = (DWORD*)(dll_base + export_directory->AddressOfNames);
    WORD *name_ord_arr = (WORD*)(dll_base + export_directory->AddressOfNameOrdinals);
    WORD *func_arr = (WORD*)(dll_base + export_directory->AddressOfFunctions);
    CHAR *api_name;
    DWORD calculated_hash;

    unsigned char *api_addr;

    for (int i = 0; i < export_directory->NumberOfNames; i++) {
        api_name = (CHAR*)dll_base + name_arr[i];
        api_addr = (unsigned char*)(dll_base + func_arr[2 * name_ord_arr[i]]);
        // printf("calculated_hash: %x, api_hash: %x\n", calculate_api_hash(api_name), api_hash);
        calculated_hash = calculate_api_hash(api_name);
        if (calculated_hash == api_hash) {
            printf("found api: %s\n", api_name);
            return api_addr;
        }
    }

    return 0;
}

WORD get_syscall_number(unsigned char *api_addr, int counter, int done) {
    
    WORD result = 0;

    while (1) {
        if (*(api_addr - 1) == 0xcc) {
            return 0;
        }
        if (!done) {
            api_addr -= 0x20;
        }
        if ((*api_addr != 0xE9) && (*(api_addr + 3) != 0xE9)) {
            break;
        }
        counter++;
        done = 0;
    }

    if ((*api_addr == 0xb8) && \
        *(api_addr + 5) == 0xe8 && \
        *(api_addr + 6) == 3 && \
        *(api_addr + 0xd) == 0x8b && \
        *(api_addr + 0xe) == 0xd4) {
            return counter + *(api_addr + 1);
        }
    
    return result;

}




// int main(int argc, char *argv[]) {

//     if (argc < 2) {
//         printf("usage %s <api_hash>\n", argv[0]);
//         return -1;
//     }

//     DWORD api_hash;
//     sscanf(argv[1], "%x", &api_hash);

//     unsigned char *ntdll_base = get_ntdll_base();
//     printf("ntdll_base: %I64x\n", ntdll_base);

//     get_api_addr(ntdll_base, api_hash);
//     return 0;

// }

int main(int argc, char *argv[]) {

    DWORD ntdll_hash;

    if (argc < 2) {
        printf("usage %s <dll_hash>\n", argv[0]);
        return -1;
    }

    DWORD dll_hash;
    sscanf(argv[1], "%x", &dll_hash);

    resolve_dll(dll_hash);

    return 0;
}