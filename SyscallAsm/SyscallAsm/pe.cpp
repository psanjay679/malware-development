#include "pe.h"


unsigned char* read_dll(char* dll_name) {

	HANDLE hFile, hHeap;
	DWORD file_size;
	unsigned char* file_data;

	hFile = CreateFileA(dll_name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE) {
		printf("Error opening file. Error: %x\n", GetLastError());
		exit(-1);
	}

	file_size = GetFileSize(hFile, NULL);
	file_data = (unsigned char*)malloc(file_size * sizeof(unsigned char));

	if (!ReadFile(hFile, (VOID*)file_data, file_size, NULL, FALSE)) {
		printf("Error reading file data. Error: %x\n", GetLastError());
		exit(-1);
	}
	return file_data;
}

DWORD64 raw_offset_addr(IMAGE_SECTION_HEADER* section, DWORD64 addr, DWORD64 base_addr) {
	return base_addr + addr + section->PointerToRawData;
}

VOID ParseDllExport(char* DllName) {

	unsigned char* FileData = read_dll(DllName);

	IMAGE_DOS_HEADER* DosHeader = (IMAGE_DOS_HEADER*)FileData;

	IMAGE_NT_HEADERS* NtHeaders = (IMAGE_NT_HEADERS*)((unsigned char*)FileData + DosHeader->e_lfanew);

	DWORD64 SectionAddr = (DWORD64)NtHeaders + sizeof(IMAGE_FILE_HEADER) + NtHeaders->FileHeader.SizeOfOptionalHeader + sizeof(DWORD);
	DWORD64 export_dir_rva = NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	IMAGE_SECTION_HEADER* ExportSection = NULL, * TextSection = NULL;
	DWORD64 RawOffset;
	IMAGE_EXPORT_DIRECTORY* ExportDirectory;

	for (int i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {
		IMAGE_SECTION_HEADER* section = (IMAGE_SECTION_HEADER*)SectionAddr;
		if (strcmp((char*)section->Name, (char*)".text") == 0) {
			TextSection = section;
		}
		if (export_dir_rva > section->VirtualAddress && export_dir_rva < section->VirtualAddress + section->SizeOfRawData) {
			ExportSection = section;
		}
		SectionAddr += sizeof(IMAGE_SECTION_HEADER);
	}

	RawOffset = (DWORD64)FileData + ExportSection->PointerToRawData;
	ExportDirectory = (IMAGE_EXPORT_DIRECTORY*)(RawOffset + export_dir_rva - ExportSection->VirtualAddress);

	WORD* ordinal_arr = (WORD*)(RawOffset - ExportSection->VirtualAddress + ExportDirectory->AddressOfNameOrdinals);
	DWORD* func_arr = (DWORD*)(RawOffset - ExportSection->VirtualAddress + ExportDirectory->AddressOfFunctions);
	DWORD* name_arr = (DWORD*)(RawOffset - ExportSection->VirtualAddress + ExportDirectory->AddressOfNames);

	printf("raw_offset: %I64x\tbase_addr: %I64x\n", RawOffset, (DWORD64)FileData);
	printf("Ordinal\t\tfunc_rva\tfunc_addr\tsyscall_no\tapi_name\n");

	for (int i = 0; i < ExportDirectory->NumberOfNames; i++) {
		WORD ordinal = ordinal_arr[i];

		char* name = (char*)(RawOffset - ExportSection->VirtualAddress + name_arr[i]);
		DWORD func_rva = func_arr[ordinal];

		DWORD* func_addr = (DWORD*)((DWORD64)FileData + func_rva - TextSection->VirtualAddress + TextSection->PointerToRawData);

		if ((name[0] == 'Z' && name[1] == 'w') || (name[0] == 'N' && name[1] == 't')) {

			printf("%03x\t\t", ordinal);
			printf("%x\t\t", func_rva);
			printf("%I64x\t", func_addr);
			printf("%04x\t\t", *(WORD*)((unsigned char*)func_addr + 4));
			printf("%s\n", name);
		}
	}
}

VOID ParseDllImport(char* dll_name) {

	unsigned char* file_data = read_dll(dll_name);
	
	IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)file_data;
	IMAGE_NT_HEADERS* nt_headers = (IMAGE_NT_HEADERS*)(dos_header->e_lfanew + file_data);
	DWORD64 raw_offset, base_addr = (DWORD64)file_data;
	IMAGE_THUNK_DATA *thunk_data;
	DWORD thunk;
	IMAGE_IMPORT_DESCRIPTOR* import_desc;
	IMAGE_SECTION_HEADER* import_section = NULL, *section;
	DWORD64 import_dir_rva, section_addr;
	
	section_addr = (DWORD64)nt_headers + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + nt_headers->FileHeader.SizeOfOptionalHeader;
	import_dir_rva = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

	for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {

		section = (IMAGE_SECTION_HEADER*)section_addr;

		if (import_dir_rva >= section->VirtualAddress && import_dir_rva <= section->VirtualAddress + section->Misc.VirtualSize) {
			import_section = section;
			break;
		}

		section_addr += sizeof(IMAGE_SECTION_HEADER);
	}

	raw_offset = (DWORD64)(base_addr + import_section->PointerToRawData);

	import_desc = (IMAGE_IMPORT_DESCRIPTOR*)(raw_offset + import_dir_rva - import_section->VirtualAddress);

	printf("***** DLL Imports *****\n");
	
	for (; import_desc->Name != 0; import_desc++) {
		DWORD name_rva = import_desc->Name;

		if (import_desc->OriginalFirstThunk == 0) {
			thunk = import_desc->FirstThunk;
		}
		else {
			thunk = import_desc->OriginalFirstThunk;
		}

		thunk_data = (IMAGE_THUNK_DATA*)(raw_offset + thunk - import_section->VirtualAddress);
		printf("%s\n", raw_offset - import_section->VirtualAddress + import_desc->Name);

		for (; thunk_data->u1.AddressOfData != 0; thunk_data++) {
			//printf("\tfunction: %x ", (WORD)thunk_data->u1.Function);
			printf("\t%s\n", raw_offset + thunk_data->u1.AddressOfData - import_section->VirtualAddress + 2);
		}
	}
}