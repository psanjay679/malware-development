#include "lib.h"


VOID inject_dll(char *pname) {

	char p_notepad[] = "notepad.exe";
	char payload_file[] = "C:\\Users\\test\\Desktop\\payload.dll";
	HANDLE hProcess, hFile, hHeap;
	LPVOID base_addr, payload_addr;
	DWORD64 delta;
	IMAGE_IMPORT_DESCRIPTOR *import_desc;
	IMAGE_DATA_DIRECTORY data_dir;
	//CHAR* payload_addr;
	DWORD fileSize, image_size;
	CHAR* lib_name;
	HMODULE hModule;
	LPSTARTUPINFOA si = new STARTUPINFOA();
	LPPROCESS_INFORMATION pi = new PROCESS_INFORMATION();

	if (pname == NULL) {
		pname = p_notepad;
	}

	// create process in suspended mode
	/*if (!CreateProcessA(NULL, pname, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, si, pi)) {
		printf("could not open process. error: %x\n", GetLastError());
		exit(-1);
	}*/

	//hProcess = pi->hProcess;


	// open payload.dll file and copy it's buffer
	hFile = CreateFileA(payload_file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE) {
		printf("could not open file. error: %x\n", GetLastError());
		exit(-1);
	}

	fileSize = GetFileSize(hFile, NULL);
	
	payload_addr = (LPVOID)malloc(fileSize * sizeof(CHAR));

	ReadFile(hFile, payload_addr, fileSize, NULL, NULL);
	
	// injection code goes here.
	
	IMAGE_DOS_HEADER* dos_header = (IMAGE_DOS_HEADER*)payload_addr;
	IMAGE_NT_HEADERS* nt_headers = (IMAGE_NT_HEADERS*)((DWORD64)payload_addr + dos_header->e_lfanew);

	//printf("Signature: %X\n", nt_headers->Signature);

	image_size = nt_headers->OptionalHeader.SizeOfImage;

	// allocate memory in remote process

	//base_addr = VirtualAllocEx(hProcess, NULL, image_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	base_addr = VirtualAlloc((LPVOID)nt_headers->OptionalHeader.ImageBase, image_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	//printf("Allocate Memory Region: %I64x\n", base_addr);

	delta = (DWORD64)base_addr - nt_headers->OptionalHeader.ImageBase;

	IMAGE_SECTION_HEADER* section = IMAGE_FIRST_SECTION(nt_headers);
	for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
		LPVOID section_addr = (LPVOID)((DWORD64)base_addr + section->VirtualAddress);
		LPVOID section_bytes = (LPVOID)((DWORD64)payload_addr + section->PointerToRawData);
		memcpy(section_addr, section_bytes, section->SizeOfRawData);
		section++;
	}

	data_dir = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];	
	import_desc = (IMAGE_IMPORT_DESCRIPTOR *)((DWORD64)base_addr + data_dir.VirtualAddress);


	while (import_desc->Name != 0) {
		lib_name = (CHAR*)(import_desc->Name + (DWORD64)base_addr);
		//printf("lib_name: %s\n", lib_name);
		hModule = LoadLibraryA(lib_name);

		if (hModule) {
			PIMAGE_THUNK_DATA tdata = NULL;
			tdata = (PIMAGE_THUNK_DATA)((DWORD64)base_addr + import_desc->FirstThunk);

			while(tdata->u1.AddressOfData != NULL) {
				if (IMAGE_SNAP_BY_ORDINAL(tdata->u1.Ordinal)) {
					char* func_name = (char*)IMAGE_ORDINAL(tdata->u1.Ordinal);
					//printf("%s ", func_name);
					tdata->u1.Function = (DWORD64)GetProcAddress(hModule, func_name);
				}
				else {
					PIMAGE_IMPORT_BY_NAME func_name = (PIMAGE_IMPORT_BY_NAME)((DWORD64)base_addr + tdata->u1.AddressOfData);
					//printf("%s ", func_name->Name);
					tdata->u1.Function = (DWORD64)GetProcAddress(hModule, func_name->Name);
				}
				tdata++;
			}
		}

		import_desc++;
	}

	DLLEntry DllEntry = (DLLEntry)((DWORD64)base_addr + nt_headers->OptionalHeader.AddressOfEntryPoint);
	(*DllEntry)((HINSTANCE)base_addr, DLL_PROCESS_ATTACH, 0);

	// kill process
	getchar();
	//TerminateProcess(hProcess, 0);
}