#pragma once
#include "headers.h"
class PEFile {
public:

	PIMAGE_DOS_HEADER image_dos_header;
	PIMAGE_NT_HEADERS image_nt_headers;
	DWORD base_addr;

	PEFile(char* file_name) {

		LPVOID file_data;
		DWORD bytes_read;
		DWORD idx = 0;

		HANDLE hfile = CreateFileA(
			file_name,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);

		if (hfile == INVALID_HANDLE_VALUE) {
			printf("Could not open file. Error %x\n", GetLastError());
			exit(-1);
		}
		printf("File open success\n");

		DWORD file_size = GetFileSize(hfile, NULL);

		file_data = HeapAlloc(GetProcessHeap(), NULL, file_size);
		ReadFile(hfile, file_data, file_size, &bytes_read, NULL);

		image_dos_header = (PIMAGE_DOS_HEADER)file_data;
		image_nt_headers = (PIMAGE_NT_HEADERS)((DWORD)image_dos_header->e_lfanew + (DWORD)file_data);
		base_addr = (DWORD)file_data;

		printf("Signature: %02X\n", image_nt_headers->Signature);
		printf("base_addr: %08X\n", base_addr);
	}

	DWORD iterate_sections() {

		DWORD image_section_header_addr =
			(DWORD)image_nt_headers + sizeof(DWORD) + sizeof(image_nt_headers->FileHeader) + image_nt_headers->FileHeader.SizeOfOptionalHeader;

		DWORD import_directory_rva = image_nt_headers->OptionalHeader.DataDirectory[1].VirtualAddress;
		DWORD import_section_addr;
		DWORD raw_offset;
		PIMAGE_SECTION_HEADER import_section;
		PIMAGE_IMPORT_DESCRIPTOR import_descriptor;

		for (int i = 0; i < image_nt_headers->FileHeader.NumberOfSections; i++) {
			PIMAGE_SECTION_HEADER section_header = (PIMAGE_SECTION_HEADER)image_section_header_addr;
			printf("name: %s\n", section_header->Name);
			printf("\tvirtual_size:	%08x\n", section_header->Misc.VirtualSize);
			printf("\tvirtual_addr:	%08x\n", section_header->VirtualAddress);
			printf("\traw_size:	%08x\n", section_header->SizeOfRawData);
			printf("\traw_addr:	%08x\n", section_header->PointerToRawData);

			if (import_directory_rva > section_header->VirtualAddress && import_directory_rva < section_header->Misc.VirtualSize + section_header->VirtualAddress) {
				import_section_addr = image_section_header_addr;
				return import_section_addr;
			}

			image_section_header_addr += sizeof(IMAGE_SECTION_HEADER);
		}
	}

	void print_imported_dlls() {

		DWORD import_section_addr = iterate_sections();
		DWORD raw_offset, import_descriptor_addr, thunk;
		PIMAGE_SECTION_HEADER import_section;
		PIMAGE_IMPORT_DESCRIPTOR import_descriptor;
		PIMAGE_THUNK_DATA thunk_data;
		DWORD import_directory_rva = image_nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

		import_section = (PIMAGE_SECTION_HEADER)import_section_addr;
		raw_offset = base_addr + import_section->PointerToRawData;

		import_descriptor_addr = raw_offset + import_directory_rva - import_section->VirtualAddress;
		import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)import_descriptor_addr;

		for (; import_descriptor->Name != 0; import_descriptor++) {
			printf("dll_name: %s\n", raw_offset + (import_descriptor->Name - import_section->VirtualAddress));

			thunk = (import_descriptor->OriginalFirstThunk == 0 ? import_descriptor->FirstThunk : import_descriptor->OriginalFirstThunk);
			thunk_data = (PIMAGE_THUNK_DATA)(raw_offset + thunk - import_section->VirtualAddress);

			for (; thunk_data->u1.AddressOfData != 0; thunk_data++) {
				printf("\t%08x\t", raw_offset + thunk_data->u1.Ordinal - import_section->VirtualAddress);
				printf("%s\n", raw_offset + thunk_data->u1.ForwarderString - import_section->VirtualAddress + 2);
			}
		}
	}

	void print_exported_functions() {


		PIMAGE_EXPORT_DIRECTORY export_directory;
		DWORD export_directory_loc;
		DWORD section_header_addr = (DWORD)image_nt_headers + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + image_nt_headers->FileHeader.SizeOfOptionalHeader;
		PIMAGE_SECTION_HEADER section_header = (PIMAGE_SECTION_HEADER)section_header_addr;
		DWORD export_section_loc, base_offset;
		DWORD export_directory_rva = image_nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;


		for (int i = 0; i < image_nt_headers->FileHeader.NumberOfSections; i++) {
			section_header = (PIMAGE_SECTION_HEADER)section_header_addr;
			printf("%s\n", section_header->Name);
			if (export_directory_rva > section_header->VirtualAddress && export_directory_rva < section_header->VirtualAddress + section_header->Misc.VirtualSize) {
				export_section_loc = section_header_addr;
				break;
			}
			section_header_addr += sizeof(IMAGE_SECTION_HEADER);
		}

		base_offset = (DWORD)image_dos_header + section_header->PointerToRawData;
		export_directory_loc = base_offset + export_directory_rva - section_header->VirtualAddress;
		export_directory = (PIMAGE_EXPORT_DIRECTORY)export_directory_loc;
		
		printf("Number of Functions: %08x\n", export_directory->NumberOfFunctions);
		printf("Number of Names: %08x\n", export_directory->NumberOfNames);
		printf("Address of Name Ordinals: %08x\n", export_directory->AddressOfNameOrdinals);
		printf("Address of Names: %08x\n", export_directory->AddressOfNames);

		DWORD address_of_name_ordinal = base_offset + export_directory->AddressOfNameOrdinals - section_header->VirtualAddress;
		DWORD address_of_name = base_offset + export_directory->AddressOfNames - section_header->VirtualAddress;

		UINT16* ptr;
		DWORD addr;
		DWORD name_addr, *name_addr_ptr, *name_ordinal_ptr, name_ordinal_addr;
		DWORD func_name_addr;
		DWORD* func_ptr, func_addr;

		printf("name ordinals on disk: %08x\n", base_offset + export_directory->AddressOfNameOrdinals  - section_header->VirtualAddress - (DWORD)image_dos_header);
		printf("names on disk:         %08x\n", base_offset + export_directory->AddressOfNames - section_header->VirtualAddress - (DWORD)image_dos_header);
		printf("address of disk:       %08x\n", base_offset + export_directory->AddressOfFunctions - section_header->VirtualAddress - (DWORD)image_dos_header);
		func_addr = base_offset + export_directory->AddressOfFunctions - section_header->VirtualAddress + 12;
		func_ptr = (DWORD*)func_addr;

		printf("func_ptr: %08x\n", *func_ptr);
		for (int i = 0; i < export_directory->NumberOfNames; i++) {

			name_ordinal_addr = (base_offset + export_directory->AddressOfNameOrdinals - section_header->VirtualAddress + 2 * i);
			ptr = (WORD*)name_ordinal_addr;
			//printf("name_ordinal_addr: %04x\t", *ptr);

			func_addr = base_offset + export_directory->AddressOfFunctions - section_header->VirtualAddress + *ptr * 4;
			func_ptr = (DWORD*)func_addr;
			printf("ptr: %04x\tfunc_ptr: %08x", *ptr, *func_ptr);

			func_addr = base_offset + *func_ptr - section_header->VirtualAddress;
			printf("\tfunc_addr: %08x\tdisk_loc: %08x", func_addr, func_addr - (DWORD)image_dos_header);

			name_addr_ptr = (DWORD*)(base_offset + export_directory->AddressOfNames - section_header->VirtualAddress + 4 * i);
			func_name_addr = (base_offset + *name_addr_ptr - section_header->VirtualAddress);
			printf("\t%s\n", func_name_addr);

		}
		//for (int i = 0; i < export_directory->NumberOfNames * 2; i += 2) {
		//	addr = (base_offset + export_directory->AddressOfNameOrdinals + i - section_header->VirtualAddress);
		//	printf("on disk: %08x\n", addr);
		//	ptr = (UINT16*)addr;
		//	//printf("%x ", &ptr);
		//	printf("%x ", *ptr);
		//	//printf("%x\n", ptr);

		//	name_addr = (base_offset + export_directory->AddressOfNames - section_header->VirtualAddress) + i;
		//	name_addr_ptr = (DWORD*)name_addr;
		//	func_name_addr = (base_offset + *name_addr_ptr - section_header->VirtualAddress);
		//	//printf("%08x ", *name_addr_ptr);
		//	//printf("%08x ", func_name_addr);
		//	//printf("%s\n", func_name_addr);
		//	//printf("\n");
		//}

	}

};



